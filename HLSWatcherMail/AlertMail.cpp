#include "stdafx.h"
#include "AlertMail.h"
#include "./CXml/Xml.h"
#include "Shlwapi.h"
#include <tlhelp32.h>

using namespace Generic; //for xml classes
HLSMONITOR hlsmonitor;

bool IsProcessRunning(const wchar_t *processName)
{
	bool exists = false;
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (Process32First(snapshot, &entry))
		while (Process32Next(snapshot, &entry))
			if (!wcsicmp(entry.szExeFile, processName))
				exists = true;
	CloseHandle(snapshot);
	return exists;
}

DWORD WINAPI WatchTXT(LPVOID lpparam)
{
	int MailCount = *((int *)lpparam);
	Sleep(10000);
	TCHAR Buffer[MAX_PATH];
	TCHAR strFile[MAX_PATH];
	DWORD dwRet;
	dwRet = GetCurrentDirectory(MAX_PATH, Buffer);
	_stprintf_s(strFile, MAX_PATH, _T("%s\\MailDir\\email_%d.txt"), Buffer, MailCount);
	int retval;
	retval = PathFileExists(strFile);
	if (retval == 1)
	{
		bool exist = IsProcessRunning(L"SendMail.exe");
		if (!exist)
		{
			TCHAR Buffer[MAX_PATH];
			TCHAR folderpath[MAX_PATH];
			DWORD dwRet;
			dwRet = GetCurrentDirectory(MAX_PATH, Buffer);
			_stprintf_s(folderpath, MAX_PATH, _T("%s\\SendMail.exe"), Buffer);
			SHELLEXECUTEINFO InterServerExecution = { 0 };
			InterServerExecution.cbSize = sizeof(SHELLEXECUTEINFO);
			InterServerExecution.fMask = SEE_MASK_NOCLOSEPROCESS;
			InterServerExecution.hwnd = NULL;
			InterServerExecution.lpVerb = NULL;
			InterServerExecution.lpFile = folderpath;
			InterServerExecution.lpParameters = _T("");
			InterServerExecution.lpDirectory = NULL;
			InterServerExecution.nShow = SW_HIDE;
			InterServerExecution.hInstApp = NULL;
			ShellExecuteEx(&InterServerExecution);
			WaitForSingleObject(InterServerExecution.hProcess, 100);
		}

	}
	return 0;
}

AlertMail::AlertMail()
{
	MailCount = 0;
	m_nAlertDurationTime = 0;
	m_nDetectionTime = 0;
	m_nTotalEmailId = 0;

	memset(m_strUserName, 0, sizeof(TCHAR) * 100);
	memset(m_strPassword, 0, sizeof(TCHAR) * 100);
	memset(m_strSMTP, 0, sizeof(TCHAR) * 100);
	memset(m_strSystemName, 0, sizeof(TCHAR) * 100);
	for(int i = 0; i < 10; i++)
		memset(m_strReceiverEmailId, 0, sizeof(TCHAR) * 100);

}

void AlertMail::ReadEmailConfiguration()
{
	CXml xml;

	CString strRoot;
	strRoot.Format(_T("EmailConfiguration"));

	_stprintf_s(m_strSystemName, 100, _T("%s"), xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("SystemName"))->GetValue());
	m_nAlertDurationTime = xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("EmailDuration"))->GetValue(0);
	m_nDetectionTime = xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("DetectionDuaration"))->GetValue(0);
	_stprintf_s(m_strSMTP, 100, _T("%s"), xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("SMTP_Server"))->GetValue());
	_stprintf_s(m_strUserName, 100, _T("%s"), xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("UserName"))->GetValue());
	_stprintf_s(m_strPassword, 100, _T("%s"), xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("PassWord"))->GetValue());
	m_nTotalEmailId = xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(_T("TotalMail"))->GetValue(0);
	for (int i = 0; i < m_nTotalEmailId; i++)
	{
		CString strReceiverMailTag;
		strReceiverMailTag.Format(L"ReceiverMail_%d", i + 1);
		_stprintf_s(m_strReceiverEmailId[i], 100, _T("%s"), xml.GetRoot()->GetChild(strRoot, TRUE)->GetChild(strReceiverMailTag)->GetValue());
	}
}

void AlertMail::SendData(HLSMONITOR monitor)
{
	memset(&Mail, 0, sizeof(MAIL));

	SYSTEMTIME lt;
	GetLocalTime(&lt);
	int Length = 0;

	if (m_nTotalEmailId > 0)
	{
		for (int i = 0; i < m_nTotalEmailId; i++)
		{
			wcstombs(Mail.To[i], m_strReceiverEmailId[i], _tcslen(m_strReceiverEmailId[i]) + 1);
		}
		wcstombs(Mail.From, m_strUserName, _tcslen(m_strUserName) + 1);
		wcstombs(Mail.UserName, m_strUserName, _tcslen(m_strUserName) + 1);
		wcstombs(Mail.Password, m_strPassword, _tcslen(m_strPassword) + 1);
		wcstombs(Mail.SMTP, m_strSMTP, _tcslen(m_strSMTP) + 1);

		char tempSystemName[100];
		wcstombs(tempSystemName, m_strSystemName, _tcslen(m_strSystemName) + 1);

		if(monitor.bHLSMonitor == true)
			Length = sprintf(Mail.Subject, "%s : HLS Chunk Downloading - Down", tempSystemName);
		else
			Length = sprintf(Mail.Subject, "%s : HLS Chunk Downloading - Up", tempSystemName);

		Length = 0;

		Length = sprintf(Mail.Text, "[%04d-%02d-%02d %02d:%02d:%02d:%03d] - %s\r\n", lt.wYear, lt.wMonth, lt.wDay, lt.wHour, lt.wMinute, lt.wSecond, lt.wMilliseconds, monitor.strMonitorMsg);

		Length += sprintf(Mail.Text + Length, "\n***This email has been auto-generated by HLSWatcher, Please Do not reply to this mail. \r\n");

	}

	SendMail();
}

void AlertMail::SendMail()
{
	TCHAR Buffer[MAX_PATH];
	TCHAR folderpath[MAX_PATH];
	DWORD dwRet;
	dwRet = GetCurrentDirectory(MAX_PATH, Buffer);
	_stprintf_s(folderpath, MAX_PATH, _T("%s\\MailDir"), Buffer);
	int retval;
	retval = PathFileExists(folderpath);
	if (retval == 0)
	{
		CreateDirectory(folderpath, NULL);
	}
	DWORD len = GetCurrentDirectory(0, NULL);
	TCHAR strFile[MAX_PATH];
	MailCount++;
	if (MailCount > 50000)
	{
		MailCount = 0;
	}

	_stprintf_s(strFile, MAX_PATH, _T("%s\\MailDir\\email_%d.txt"), Buffer, MailCount);
	CFile outputfile;
	CFileException excOutputfile;

	int BUF_LENGTH = 500 * 5 + 100;
	char* strPrintMsg = new char[BUF_LENGTH];
	memset(strPrintMsg, 0, BUF_LENGTH);

	if (outputfile.Open(strFile, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeWrite | CFile::typeBinary, &excOutputfile))
	{
		sprintf(strPrintMsg, "%s \r\n", Mail.SMTP);
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "%s \r\n", Mail.From);
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "PASSWORD: \r\n");
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "%s \r\n", Mail.Password);
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "TO: \r\n");
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		for (int listno = 0; listno < m_nTotalEmailId; listno++)
		{
			sprintf(strPrintMsg, "%s \r\n", Mail.To[listno]);
			outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		}
		sprintf(strPrintMsg, "SUBJECT: \r\n");
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "%s \r\n", Mail.Subject);
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "BODY: \r\n");
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		sprintf(strPrintMsg, "%s \r\n", Mail.Text);
		outputfile.Write(strPrintMsg, strlen(strPrintMsg) * sizeof(char));
		outputfile.Close();
	}

	CreateThread(0, 0, WatchTXT, &MailCount, 0, 0);
	delete[] strPrintMsg;
	strPrintMsg = NULL;
}